module Walk

open Graph
open FSharpx
open FSharpx.Option
open VDS.RDF
open VDS.RDF.Parsing
open System.IO

type Graph =
  | Graph of IGraph
  static member from (s : string) =
    let g = new VDS.RDF.Graph()
    let p = TurtleParser()
    use sr = new StringReader(s)
    p.Load(g, sr)
    Graph g

module private GetTriples =
  let uriNode u (g:IGraph) = g.GetUriNode(u |> Uri.toSys)
  let bySubject u (g:IGraph) = g.GetTriplesWithSubject (uriNode u g)
  let byObject u (g:IGraph) = g.GetTriplesWithObject (uriNode u g)
  let byPredicate u (g:IGraph) = g.GetTriplesWithPredicate (uriNode u g)
  let byPredicateObject p o (g:IGraph) = g.GetTriplesWithPredicateObject (uriNode p g,uriNode o g)
  let bySubjectObject p o (g:IGraph) = g.GetTriplesWithSubjectObject (uriNode p g,uriNode o g)
  let bySubjectPredicate p o (g:IGraph) = g.GetTriplesWithSubjectPredicate (uriNode p g,uriNode o g)

  let triplesToStatement (t:Triple seq) =
    t
    |> Seq.groupBy (fun t -> t.Subject)
    |> Seq.map (fun (s, tx) ->
        (Subject(Node.from s)),
        [ for t in tx ->
            (Predicate(Node.from t.Predicate), Object(Node.from t.Object)) ])
    |> List.ofSeq

  let fromSingle (f:Uri -> IGraph -> Triple seq) x g =
    match g with
    | Graph g -> f x g |> triplesToStatement
  let fromDouble (f:Uri -> Uri -> IGraph -> Triple seq) x y g =
    match g with
    | Graph g -> f x y g |> triplesToStatement

open GetTriples
let fromSubject<'a> u g   = fromSingle bySubject u g
let fromPredicate<'a> u g = fromSingle byPredicate u g
let fromObject<'a> u g = fromSingle byObject u g
let fromPredicateObject<'a> x y g = fromDouble byPredicateObject x y g
let fromSubjectObject<'a> x y g = fromDouble bySubjectObject x y g
let fromSubjectPredicate<'a> x y g = fromDouble bySubjectPredicate x y g

let asTriples x =
  match x with
  | (s, px) ->
    [ for (p, o) in px -> (s, p, o) ]

type Parser<'a> = | T of (Statements list -> ('a * Statements list) list)
    
module parsers =
    (*Statements for Predicate p*)
    let pred p (sx:Statements) : Statements =
        match sx with
            | (s, px) ->
            (s, px |> List.filter p)

    let forPredicate p = pred((function (p',_) -> p = p'))

    let mapSubject f (sx:Statements) =
        [match sx  with
            | (s,_) -> yield f s]
    let mapPredicate f (sx:Statements list) =
        [for sx in sx do
            match sx with
                | (s,px) ->
                for p in px do
                    match p with
                    | (Predicate p,_) -> yield f p ]
    let mapObject f (sx:Statements list) =
        [for s in sx do
            match s with
                | (s,px) ->
                for p in px do
                    match p with
                | (_,Object o) -> yield f o ]

    let tr (sx:Statements list) : Statements list=
        let traverse (sx:Statements list) = [
            printfn "------Traversing %A" sx
            for sx in sx do
            match sx with
                | (s,px) ->
                    for p in px do
                    match p with
                    | (_, Object(Node.Uri(Uri.VDS vds))) ->
                    yield bySubject (Uri.VDS vds) (vds.Graph) |> triplesToStatement
                    | _ -> ()
            ]
        traverse sx |> List.concat


    let unit x = T (fun sx -> [(x,sx)])
    let fromSeq sx = T (fun sx' -> [(),sx])
    //Run first , then second generated by f
    let bind f (T t) = T (fun sx ->
                                    [for (v, sx) in t sx do
                                            let (T t') = f v
                                            yield! t' sx])
    //Traversal that takes any statement list and returns nothing
    let zero () = T (fun sx -> [])
    //Apply to all results
    let combine (T t) (T t') = T (fun sx ->  t sx@t' sx)
    //Produce a parser for statements where predicate is p
    let predicate p (T t) = T (fun sx -> t(sx |> List.map ( forPredicate p )))
    //Produce a parser where producing f applied to object component of statements
    let o pr f (T t) = T (fun sx ->
                        let sx' = sx |> List.map ( forPredicate pr )
                        [for (v,s) in t sx' do
                         yield (mapObject f s,sx) ])
    let traverse pr (T t) =  T (fun sx -> t(tr sx))
    let run (T t) = List.ofSeq >> t >> Seq.map fst >> Seq.tryPick Some

module Literal =
  open VDS.RDF
  let mapL f n =
    match n with
      | Node.Literal l -> Some (f l)
      | _ -> None

  let mapString = mapL (fun l -> l.Value)
  let mapInt = mapL (fun l -> int l.Value)
  let mapDateTime = mapL (fun l -> System.DateTime.Parse l.Value)
  let mapDateTimeOffset = mapL (fun l -> System.DateTimeOffset.Parse l.Value)


type WalkBuilder () =
  member this.Zero  = parsers.zero
  member this.Bind (t,f) =  parsers.bind f t
  member this.Yield v = parsers.unit v
  member this.YieldFrom (T t) = (T t)
  member this.Combine (x,y) = parsers.combine x y
  member this.For (p,f) = parsers.bind f p
  member this.For (sx:Statements list,f) = T (fun sx' -> [(f sx,sx)])
  //Statements for predicate p
  [<CustomOperation("wherePredicate", AllowIntoPattern=true,MaintainsVariableSpace=true)>]
  member x.wherePredicate (p,f) = parsers.predicate f p
  member x.Delay(f) = T (fun sx -> let (T op) = f () in op sx)
  //Apply f to object for statements
  [<CustomOperation("o", AllowIntoPattern=true,MaintainsVariableSpace=true)>]
  member x.o (p,f,pr) = parsers.o f pr p
  [<CustomOperation("traverse", AllowIntoPattern=true,MaintainsVariableSpace=true)>]
  member x.traverse (t,pr) = parsers.traverse pr t

let walk = new WalkBuilder()

module Combinators =
    let rec oneOrMore p = walk {
        let! x = p
        let! xs = zeroOrMore p
        yield x::xs }

    and zeroOrMore p = walk {
        yield! oneOrMore p
        yield [] }

    let andThen p p' = walk {
      let! p = p
      let! p' = p'
      yield (p,p')
      }
    let (<*>) p p' = p andThen p'
