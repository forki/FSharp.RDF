module Traversal

open Graph
open FSharpx
open FSharpx.Option
open VDS.RDF
open VDS.RDF.Parsing
open System.IO

type Graph =
  | Graph of IGraph
  static member from (s : string) =
    let g = new VDS.RDF.Graph()
    let p = TurtleParser()
    use sr = new StringReader(s)
    p.Load(g, sr)
    Graph g


module private GetTriples =
  let uriNode u (g:IGraph) = g.GetUriNode(u |> Uri.toSys)
  let bySubject u (g:IGraph) = g.GetTriplesWithSubject (uriNode u g)
  let byObject u (g:IGraph) = g.GetTriplesWithObject (uriNode u g)
  let byPredicate u (g:IGraph) = g.GetTriplesWithPredicate (uriNode u g)
  let byPredicateObject p o (g:IGraph) = g.GetTriplesWithPredicateObject (uriNode p g,uriNode o g)
  let bySubjectObject p o (g:IGraph) = g.GetTriplesWithSubjectObject (uriNode p g,uriNode o g)
  let bySubjectPredicate p o (g:IGraph) = g.GetTriplesWithSubjectPredicate (uriNode p g,uriNode o g)

  let triplesToStatement (t:Triple seq) =
    t
    |> Seq.groupBy (fun t -> t.Subject)
    |> Seq.exactlyOne
    |> (fun (s, tx) ->
    (Subject(Node.from s)),
    [ for t in tx ->
        (Predicate(Node.from t.Predicate), Object(Node.from t.Object)) ])

  let fromSingle (f:Uri -> IGraph -> Triple seq) x g =
    match g with
    | Graph g -> f x g |> triplesToStatement
  let fromDouble (f:Uri -> Uri -> IGraph -> Triple seq) x y g =
    match g with
    | Graph g -> f x y g |> triplesToStatement

open GetTriples
let fromSubject<'a> u g   = fromSingle bySubject u g
let fromPredicate<'a> u g = fromSingle byPredicate u g
let fromObject<'a> u g = fromSingle byObject u g
let fromPredicateObject<'a> x y g = fromDouble byPredicateObject x y g
let fromSubjectObject<'a> x y g = fromDouble bySubjectObject x y g
let fromSubjectPredicate<'a> x y g = fromDouble bySubjectPredicate x y g

let asTriples x =
  match x with
  | (s, px) ->
    [ for (p, o) in px -> (s, p, o) ]

(*Statements for Predicate p*)
let pred p (sx:Statements) : Statements =
  match sx with
    | (s, px) ->
      (s, px |> List.filter p)

let forPredicate p = pred((function (p',_) -> p = p'))


type Parser<'a> = | T of (Statements list -> 'a list)
module parsers =
  let unit x = T (fun sx -> [x,sx])
  //Run first , then second generated by f
  let bind f (T t) =
    T (fun sx -> [
           for s in sx do
            let (T t') = f s
            yield! t' sx
         ]
       )
  //Traversal that takes any statement list and returns nothing
  let zero () = T (fun sx -> [])
  //Apply to all results
  let combine (T t) (T t') = T (fun sx ->
    List.concat [ t sx; t' sx ])
  //Produce a parser for statements where predicate is p
  let predicate p (T t) = T (fun sx -> t(sx |> List.map (forPredicate p)))

(*
let traverse<'a>(p:Statements->Statements) (t:Traversal<'a>) : Traversal<'a> =
  let rec traverse (sx:Statements) = [
    match sx with
        | (s,px) ->
            for p in px do
            match p with
            | (_, Object(Node.Uri(Uri.VDS vds))) ->
            yield bySubject (Uri.VDS vds) (vds.Graph) |> triplesToStatement
    ]
  match T with
  | T([sx]::h) ->
    let sx' = p sx
              |> traverse
    Traversal (sx'::[sx]::h)

let where<'a> c (tr:Traversal) : Traversal =
  match tr with
    | Traversal([sx]::h) ->
      Traversal([(c sx)]::[sx]::h)


let (==>) tr (p:Predicate) = traverse (forPredicate p) tr
*)
let (.>) sx p = parsers.bind  forPredicate p sx


let mapSubject f (sx:Statements list) =
  [for s in sx do
    match s with
    | (s,_) -> yield f s]
let mapPredicate f (sx:Statements list) =
  [for s in sx do
    match s with
    | (s,px) ->
    for p in px do
        match p with
        | (Predicate p,_) -> yield f p ]
let mapObject f (sx:Statements list) =
  [for s in sx do
    match s with
    | (s,px) ->
    for p in px do
        match p with
        | (_,Object o) -> yield f o ]

let (<*-->) = mapSubject
let (<-*->) = mapPredicate
let (<--*>) = mapObject

module Literal =
  open VDS.RDF
  let mapL f n =
    match n with
      | Node.Literal l -> Some (f l)
      | _ -> None

  let mapString = mapL (fun l -> l.Value)
  let mapInt = mapL (fun l -> int l.Value)
  let mapDateTime = mapL (fun l -> System.DateTime.Parse l.Value)
  let mapDateTimeOffset = mapL (fun l -> System.DateTimeOffset.Parse l.Value)


type ParserBuilder () =
  member this.Zero  = parsers.zero
  member this.Bind (t,f) = parsers.bind f t
  member this.Yield v = parsers.unit v
  member this.YieldFrom sx = sx
  member this.Combine (x,y) = parsers.combine x y
  member this.For (t,f) = parsers.bind f t
  member x.Delay(f) = T (fun sx ->
    let (T p) = f () in p sx)
  [<CustomOperation("predicate", AllowIntoPattern=true,MaintainsVariableSpace=true)>]
  member x.predicate (p,f) = parsers.predicate f p
let parse = new ParserBuilder()
